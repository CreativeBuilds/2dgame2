var express = require('express');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);
const mongo = require('mongodb');
const mongoose = require('mongoose');
var passport = require('passport');
var GoogleStrategy = require('passport-google-oauth20').Strategy;
var passportSocketIo = require('passport.socketio');

var cookieParser = require('cookie-parser');

var session = require('express-session');
const MongoStore = require('connect-mongo')(session);
const {google} = require('googleapis');

var sessionMiddleware = session({
  name:'express.sid',
  secret:'potatos',
  resave:false,
  saveUninitialized:true,
  store: new MongoStore({
    url: "mongodb://localhost/8bitish"
  })
})

var diff = function (a, b) { return Math.abs(a - b); }

const config = require('./config.json');

const fs = require('fs');

mongoose.connect('mongodb://localhost/8bitish');

mongoose.connection.on('connected', function(){

  // var user = new User({username:'CreativeBuilds',email:'ihatemongodbs@gmail.com'});

  // user.save();

  
})

var Schema = mongoose.Schema;

var UserSchema = new Schema({
  username:String,
  email:String,
  firstLogon:Boolean
});

UserSchema.statics.findOneOrCreate = function findOneOrCreate({condition, obj}, callback){
  const self = this;
  if(!condition){return callback("No condition provided");}
  if(!obj){obj = condition}
  self.findOne(condition, (err, result) => {
    if(err || result === null){
      //Theres no user
      self.create(obj, (err, result) => {
        return callback(err, result);
      })
    } else {
      return callback(err, result);
    }
  })
}

var User = mongoose.model('User', UserSchema);

var PlayerSchema = new Schema({
  userid:{type: String},
  level:{type: String},
  tileFrom:{type: Array},
  tileTo:{type: Array},
  timeMove: {type: Number},
  dimensions: {type: Array},
  delayMove: {type: Number},
  playerLevel:{type: Number},
  sprites: {type: {
    0: [{x:0,y:0,w:32,h:32}],
    1: [{x:32,y:0,w:32,h:32}],
    2: [{x:64,y:0,w:32,h:32}],
    3: [{x:96,y:0,w:32,h:32}]
  }},
  stats:{type: {
    strength:Number,
    speed:Number,
    intellect:Number,
    health:Number,
    maxHealth:Number,
    regen:Number
  }},
  statPoints:{type: Number}
})

var Player = mongoose.model('Player', PlayerSchema);



// Loop through every file in the schema folder
// fs.readdir(__dirname+'/schemas', function(err, files) {
//   if (err) {
//       console.error("Could not list the directory.", err);
//       process.exit(1);
//   }

//   files.forEach(function(file, index) {
//       // Make one pass and make the file complete

//       let name = file.replace('.js','');
//       exports[name] = require(__dirname+'/schemas/'+file);

//   });
// });




  passport.use(new GoogleStrategy({
      clientID: config.clientId, //Generated by google
      clientSecret: config.clientSecret, //Generated by google
      callbackURL: 'http://localhost:3000/auth/callback/google'
    },
  function(accessToken, refreshToken, profile, done) {
    
    //Find the user in the database, if the user doesn't exist
    //Make a new use object!

      User.findOneOrCreate({condition:{email:profile.emails[0].value},obj:{email:profile.emails[0].value,username:profile.displayName,firstLogon:true}}, function(err, result){
        done(err, result);
      })
    }
  ));

  // used to serialize the user for the session
  passport.serializeUser(function(user, done) {
    console.log(user._id);
    done(null, user._id.toString()); 
  });

  // used to deserialize the user
  passport.deserializeUser(function(id, done) {
    User.findOne({_id:id}, function(err, user) {
        done(err, user);
    });
  });

  // app.use(session({
  //   secret:'potatos',
  //   cookie:{
  //     maxAge:1000*60*60*24
  //   },
  //   resave:false,
  //   saveUninitialized:true
  // }))
  app.use(sessionMiddleware);

  

  app.use(passport.initialize());
  app.use(passport.session());

function init(){
  http.listen(3000, function(){
    console.log('listening on *:3000');
  });
  
}


app.get('/', function(req, res){
  if(req.user){
    console.log(req.user);
    res.sendFile(__dirname + '/html/index.html');
  } else {
    console.log('redirected!');
    res.redirect('/login')
  }
  
});

app.get('/auth/callback/google', 
    passport.authenticate('google', { failureRedirect: '/login' , successRedirect: '/'})
);

app.get('/login', passport.authenticate('google', {prompt: 'select_account', scope:['profile email']}));

app.get('/logout', function(req,res){
  req.logout();
  res.redirect('/');
})

app.use(express.static('html'))


let sockets = [];

io.use(passportSocketIo.authorize({
  cookieParser: cookieParser,       // the same middleware you registrer in express
  key:          'express.sid',       // the name of the cookie where express/connect stores its session_id
  secret:       'potatos',    // the session_secret to parse the cookie
  store: new MongoStore({
    url: 'mongodb://localhost/8bitish'
  }),
  resave:false,
  saveUninitialized:true
}));

//TODO on user disconnect, check the level that they were on to see if anyone else is connected there.
//If not, then save the map file and unload it from mem.
let maps = {}

function getPlayer(userID, callback){
  Player.findOne({userid: userID.toString()}, function(err, player){
    callback(err, player);
  })
}

function updatePlayer(socket, player){
  socket.emit('updatePlayer', player);
}

var connect = require('connect');
io.on('connection', function(socket){
  /* see if the user is logged on */
  // If they're not logged on, send them to logon screen

  socket.cookie = socket.handshake.headers.cookie || socket.request.headers.cookie;
  socket.sessionid = socket.cookie.substr(socket.cookie.indexOf('express.sid=s%3A')+16,32);
  let mongoStore = new MongoStore({
    url: "mongodb://localhost/8bitish"
  })
  mongoStore.get(socket.sessionid, function (err, session) {
    User.findById(session.passport.user, function(err, user){
      if(user){
        socket.user = user;
        Player.findOne({userid:session.passport.user}, function(err, player){
          if(player === null){
            //Theres no player object, first time logging in?
            Player.create({
              userid:session.passport.user,
              level:"island_01",
              position:{x:36,y:57},
              playerLevel:1,
              stats:{
                strength:0,
                speed:0,
                intellect:0,
                health:100,
                maxHealth:100,
                regen:1
              },
              statPoints:10
            }, function(err, player){
              if(err){
                console.error(err);
              } else {
                socket.player = player;
              }
            })
          }
        })
      }
      delete mongoStore;
    })
    //HOORAY NOW YOU'VE GOT THE SESSION OBJECT!!!!
  });

  sockets.push(socket);

  /* Make sure to save all client info */
  socket.on('disconnect', function(){
    sockets.splice(sockets.indexOf(socket), 1);
  })
    /*
     * Send the user all the maps
     * TODO make it so we can have a level system aka (castle.map, lake.map etc)
     */
  socket.on('loadmaps', function(folderDir){
    if(!folderDir){folderDir = 'island_01'}

    if(!maps[folderDir]){
      fs.readdir(__dirname+`/levels/${folderDir}`, function(err, files) {
        if (err) {
            console.error("Could not list the directory.", err);
        } else {
          maps[folderDir] = [];
          files.forEach(function(file, index) {
            // Make one pass and make the file complete
          let map = require(__dirname+`/levels/${folderDir}/${file}`);
          let name = file.replace('.json','');
          let obj = {
            "name":name,
            "map":map
          };
            maps[folderDir].push(obj)
            socket.emit('map',obj)
      
        });
        }
      
        
      });
    } else {
      for(obj of maps[folderDir]){
        socket.emit('map', obj);
      }
    }

      //socket.emit('map', require())
  })


  /*
   * The user is moving!
   */
  //TODO Fix multiple socket error
  //If the user opens multiple tabs, and trys to move on one, then on the other, this will pass in the current setup
  //Make it so when the user connects, see if the player is already connected to another socket, if so, close that socket.

  socket.on('move', function(moveTo){
    //socket.player is going to be a player object from the DB;
    //this means it has a tileFrom and tileTo
    let position = socket.player.tileFrom;
    //Check to see if the movement the player want's to do is valid.

    if(diff(moveTo.x, position.x) < 2){
      if(diff(moveTo.y, position.y) > 0){} else {
        //Send the user a updated player object;
        socket.player.moveTo = moveTo;
      }
    }

    if(diff(moveTo.y, position.y) < 2){
      if(diff(moveTo.x, position.x) > 0){} else {
        //Send the user a updated player object;
        socket.player.moveTo = moveTo;
      }
    }

    updatePlayer(socket, socket.player);


  })

  /*
   * The user is wanting to chop a tree
   * 1. Check to see if there is a tree there!
   * 2. Run tree.chop
   */

  socket.on('chopTree', function(tree){
    let user = socket._user;
    //user is a User object tied to socket
    //tree is a Tree object 

    
  })
});


init();
